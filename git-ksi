#!/usr/bin/env python3

import sys
import json
from base64 import b64encode
import requests
from hashlib import sha256
from getpass import getpass
from signal import signal, SIGINT, SIG_IGN
from subprocess import check_output, check_call, CalledProcessError

# Catena communication constants
URL_BASE = "https://%s@tryout-catena-db.guardtime.net/api/v1/signatures"
HEADER = {"Content-Type": "application/json", "Accept": "application/json"}
SIGN_JSON_BASE = {'dataHash': {'algorithm': 'SHA-256', 'value': None}, 'metadata': {}, 'level': 0}
ID_ASSIGN_JSON_BASE = {"metadata": {}, "signature": None}


class KSICommunicator(object):
    """ Class to communicate with KSI Catena middleware """

    def __init__(self, uname, upass):
        """ Class initializer

        :param uname: string username of a KSI user
        :param upass: string password that corresponds
                      to the username above

        """

        self.username = uname
        self.password = upass
        self.uurl = URL_BASE % ("%s:%s" % (uname, upass))

    def sign_with_ksi(self, data_str):
        """ Sign specified string with KSI

        :param data_str: ?string? to sign with KSI
        :return: ####string#?#?#?# KSI signature

        """

        data_hash = self.__get_data_digest_sha256(data_str=data_str)
        req_json = SIGN_JSON_BASE.copy()
        req_json['dataHash']['value'] = data_hash
        r = requests.post(self.uurl, headers=HEADER, json=req_json)
        return json.loads(r.text)['signature']

    def assign_uid_to_signature(self, signature):
        """ Assign UID to a signature in Catena DB

        :param signature: ####string#?#?#?# KSI signature
        :return: string UID of a signature in Catena DB

        """

        req_json = ID_ASSIGN_JSON_BASE.copy()
        req_json['signature'] = signature
        r = requests.put(self.uurl, headers=HEADER, json=req_json)
        return json.loads(r.text)['id']

    def get_signature(self, id):
        """ Get KSI signature by it's UID from Catena DB

        :param id - ####string#?#?#?# UID of a signature to get from Catena DB
        :return: ####string#?#?#?# KSI signature

        """

        url_id = self.uurl + "/" + id
        r = requests.get(url_id, headers=HEADER)
        return json.loads(r.text)['signature']

    @staticmethod
    def __get_data_digest_sha256(data_str):
        """ Hash bytes-like object? ??? ? """

        return b64encode(sha256(data_str).digest()).decode()


def init_sign_process():
    """ Initiate signing process

    Get KSI credentials from user and GIT

    """

    # retrieve SHA1 commit hash
    commit_checksum = check_output(["git", "show"])[7:47]

    # temporarily disable ctrl-c while input is active
    s = signal(SIGINT, SIG_IGN)

    # ask user for credentials
    print(" ** Please enter your KSI credentials to sign this commit")
    username = input("username: ")
    password = getpass("password: ")

    # enable ctrl-c back
    signal(SIGINT, s)

    ksi_com = KSICommunicator(username, password)
    ksi_com.sign_with_ksi(commit_checksum)


def set_ctrl_c_handler(signum, frame):
    """ Specify ctrl-c handler to prevent interruption of signing process """

    if input(">> Are you sure you want to quit a signing process? (Y/n): ") == 'Y':
        exit(0)

# set ctrl-c handler
signal(SIGINT, set_ctrl_c_handler)

# pipe command to git executable
try:
    check_call(['git'] + sys.argv[1:])
except CalledProcessError:
    exit(1)

# if commit was made sign it with ksi
if sys.argv[1] == 'commit':
    pass

elif sys.argv[1] == 'sign':
    # sign last commit (usually because
    # of commit hook has failed)
    pass





